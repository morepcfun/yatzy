<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Yatzy Terningspill</title>
<link rel="icon" href="data:image/png;base64,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">

<style>
:root {
--bg-color: #1a1a2e;
--surface-color: #16213e;
--primary-color: #e94560;
--secondary-color: #0f3460;
--text-color: #dcdce6;
--highlight-color: #f0e68c;
--dice-bg: #ffffff;
--dice-dot: #1a1a2e;
--font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}
* {
box-sizing: border-box;
margin: 0;
padding: 0;
}
html,
body {
height: 100%;
width: 100%;
overflow: hidden;
font-family: var(--font-family);
background-color: var(--bg-color);
color: var(--text-color);
display: flex;
justify-content: center;
align-items: center;
font-size: 16px;
}
.game-container {
width: 100%;
height: 100%;
display: flex;
flex-direction: column;
padding: 1.5vmin;
gap: 1.5vmin;
max-width: 1400px;
}
.top-panel {
display: flex;
justify-content: space-between;
align-items: center;
flex-shrink: 0;
gap: 15px;
}
.top-panel-info {
display: flex;
align-items: baseline;
gap: 20px;
}
.main-content {
display: flex;
flex-grow: 1;
gap: 1.5vmin;
height: calc(100% - 160px);
}
.scoreboard-container {
flex-grow: 1;
overflow-y: auto;
background: var(--surface-color);
border-radius: 10px;
box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
padding: 1vmin;
}
.scoreboard {
width: 100%;
border-collapse: collapse;
}
.scoreboard th,
.scoreboard td {
padding: 1.0vmin;
text-align: left;
border-bottom: 1px solid var(--secondary-color);
}
.scoreboard th {
font-size: clamp(12px, 2vmin, 18px);
color: var(--primary-color);
}
.scoreboard td {
font-size: clamp(12px, 1.8vmin, 16px);
text-align: center;
}
.scoreboard th:first-child,
.scoreboard td:first-child {
text-align: left;
font-weight: bold;
}
.player-header {
font-size: clamp(16px, 3vmin, 24px) !important;
position: sticky;
top: 0;
background: var(--surface-color);
}
.score-cell {
cursor: pointer;
border-radius: 5px;
transition: background-color 0.2s;
}
.score-cell.filled {
font-weight: bold;
color: var(--highlight-color);
cursor: not-allowed;
}
.total-score-row td {
font-weight: bold;
font-size: clamp(14px, 2.2vmin, 20px);
color: var(--primary-color);
border-top: 2px solid var(--primary-color);
}
@keyframes pulse-glow {
    0% { box-shadow: 0 0 3px var(--highlight-color); }
    50% { box-shadow: 0 0 12px 3px var(--highlight-color); }
    100% { box-shadow: 0 0 3px var(--highlight-color); }
}

/* Alle klikkbare ruter f√•r hover-effekt */
.score-cell.available:hover {
    background-color: var(--secondary-color);
    color: var(--highlight-color);
}

/* Kun ruter som er forslag f√•r den pulserende effekten */
.score-cell.suggestion {
    animation: pulse-glow 2s infinite ease-in-out;
}

.control-panel {
display: flex;
flex-direction: column;
gap: 1.5vmin;
width: 300px;
flex-shrink: 0;
}
.player-info,
.dice-area,
.game-controls {
background: var(--surface-color);
padding: 2vmin;
border-radius: 10px;
box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
display: flex;
flex-direction: column;
align-items: center;
gap: 1.5vmin;
}
.player-info h2 {
font-size: clamp(18px, 2.5vmin, 24px);
color: var(--primary-color);
}
.player-info p {
font-size: clamp(14px, 2vmin, 18px);
}
.dice-container {
display: grid;
grid-template-columns: repeat(3, 1fr);
gap: 1vmin;
width: 100%;
}
.dice {
width: clamp(40px, 10vmin, 70px);
height: clamp(40px, 10vmin, 70px);
background-color: var(--dice-bg);
border-radius: 10px;
cursor: pointer;
display: flex;
justify-content: center;
align-items: center;
box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
transition: transform 0.2s, box-shadow 0.2s;
position: relative;
}
.dice.no-click {
cursor: not-allowed;
}
.dice:nth-child(4),
.dice:nth-child(5) {
grid-column: span 1.5;
}
.dice.held {
transform: scale(0.9);
box-shadow: 0 0 15px 3px var(--highlight-color);
border: 2px solid var(--highlight-color);
}
.dice .dot {
width: clamp(8px, 2vmin, 15px);
height: clamp(8px, 2vmin, 15px);
background-color: var(--dice-dot);
border-radius: 50%;
position: absolute;
}
.dice[data-value="1"] .dot:nth-child(1) { top: 50%; left: 50%; transform: translate(-50%, -50%); }
.dice[data-value="2"] .dot:nth-child(1) { top: 25%; left: 25%; transform: translate(-50%, -50%); }
.dice[data-value="2"] .dot:nth-child(2) { top: 75%; left: 75%; transform: translate(-50%, -50%); }
.dice[data-value="3"] .dot:nth-child(1) { top: 25%; left: 25%; transform: translate(-50%, -50%); }
.dice[data-value="3"] .dot:nth-child(2) { top: 50%; left: 50%; transform: translate(-50%, -50%); }
.dice[data-value="3"] .dot:nth-child(3) { top: 75%; left: 75%; transform: translate(-50%, -50%); }
.dice[data-value="4"] .dot:nth-child(1) { top: 25%; left: 25%; transform: translate(-50%, -50%); }
.dice[data-value="4"] .dot:nth-child(2) { top: 25%; left: 75%; transform: translate(-50%, -50%); }
.dice[data-value="4"] .dot:nth-child(3) { top: 75%; left: 25%; transform: translate(-50%, -50%); }
.dice[data-value="4"] .dot:nth-child(4) { top: 75%; left: 75%; transform: translate(-50%, -50%); }
.dice[data-value="5"] .dot:nth-child(1) { top: 25%; left: 25%; transform: translate(-50%, -50%); }
.dice[data-value="5"] .dot:nth-child(2) { top: 25%; left: 75%; transform: translate(-50%, -50%); }
.dice[data-value="5"] .dot:nth-child(3) { top: 50%; left: 50%; transform: translate(-50%, -50%); }
.dice[data-value="5"] .dot:nth-child(4) { top: 75%; left: 25%; transform: translate(-50%, -50%); }
.dice[data-value="5"] .dot:nth-child(5) { top: 75%; left: 75%; transform: translate(-50%, -50%); }
.dice[data-value="6"] .dot:nth-child(1) { top: 25%; left: 25%; transform: translate(-50%, -50%); }
.dice[data-value="6"] .dot:nth-child(2) { top: 50%; left: 25%; transform: translate(-50%, -50%); }
.dice[data-value="6"] .dot:nth-child(3) { top: 75%; left: 25%; transform: translate(-50%, -50%); }
.dice[data-value="6"] .dot:nth-child(4) { top: 25%; left: 75%; transform: translate(-50%, -50%); }
.dice[data-value="6"] .dot:nth-child(5) { top: 50%; left: 75%; transform: translate(-50%, -50%); }
.dice[data-value="6"] .dot:nth-child(6) { top: 75%; left: 75%; transform: translate(-50%, -50%); }
.game-btn {
width: 100%;
padding: 15px;
font-size: clamp(16px, 2.2vmin, 20px);
font-weight: bold;
border: none;
border-radius: 8px;
background-color: var(--primary-color);
color: var(--text-color);
cursor: pointer;
transition: background-color 0.2s, transform 0.1s, display 0.1s;
}
.game-btn.secondary {
background-color: transparent;
border: 2px solid var(--primary-color);
width: auto;
padding: 4px 8px;
}
.game-btn:hover:not(:disabled) {
background-color: #ff6b81;
}
.game-btn.secondary:hover:not(:disabled) {
background-color: var(--primary-color);
}
.game-btn:active:not(:disabled) {
transform: scale(0.98);
}
.game-btn:disabled {
background-color: var(--secondary-color);
color: #6c757d;
cursor: not-allowed;
}
.modal-overlay {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.7);
display: flex;
justify-content: center;
align-items: center;
z-index: 1000;
opacity: 0;
visibility: hidden;
transition: opacity 0.3s, visibility 0.3s;
}
.modal-overlay.visible {
opacity: 1;
visibility: visible;
}
.modal-content {
background: var(--surface-color);
padding: 30px 40px;
border-radius: 15px;
text-align: center;
box-shadow: 0 0 30px var(--primary-color);
border: 1px solid var(--primary-color);
max-width: 90%;
max-height: 90%;
overflow-y: auto;
}
.modal-content h2 {
font-size: 1.6em;
margin-bottom: 20px;
color: var(--primary-color);
}
.modal-content p {
margin-bottom: 30px;
font-size: 1.2em;
}
.modal-buttons {
display: flex;
gap: 20px;
justify-content: center;
}
.rules-content {
text-align: left;
}
.rules-content h2 {
color: var(--primary-color);
margin-top: 20px;
margin-bottom: 10px;
}
.rules-content ul {
list-style: none;
padding-left: 0;
}
.rules-content li {
margin-bottom: 10px;
}
.rules-content strong {
color: var(--highlight-color);
}
@media (max-width: 768px) {
body {
overflow: auto;
}
.game-container {
height: auto;
}
.main-content {
flex-direction: column;
height: auto;
}
.control-panel {
width: 100%;
flex-direction: row;
flex-wrap: wrap;
justify-content: space-around;
}
.player-info,
.dice-area,
.game-controls {
flex-basis: 45%;
flex-grow: 1;
}
}
h1 {
font-size: 1.6em;
margin-bottom: 20px;
color: var(--primary-color);
margin-bottom: 0;
}
</style>
</head>
<body>
<div class="game-container">
<div class="top-panel">
<div class="top-panel-info">
<p id="game-mode-display"></p>
</div>
<button id="rules-btn" class="game-btn secondary"></button>
</div>
<div class="main-content">
<div class="scoreboard-container">
<table class="scoreboard" id="scoreboard">
</table>
</div>
<div class="control-panel">
<div class="player-info">
<h2 id="current-player-name"></h2>
<p id="rolls-left"></p>
</div>
<div class="dice-area">
<div class="dice-container" id="dice-container">
</div>
</div>
<div class="game-controls">
<button id="roll-btn" class="game-btn"></button>
<button id="confirm-btn" class="game-btn" style="display: none;"></button>
</div>
</div>
</div>
</div>
<div id="start-modal" class="modal-overlay">
<div class="modal-content">
<h2 id="welcome-title"></h2>
<p id="mode-select-text"></p>
<div class="modal-buttons">
<button id="free-mode-btn" class="game-btn"></button>
<button id="forced-mode-btn" class="game-btn"></button>
</div>
</div>
</div>
<div id="game-over-modal" class="modal-overlay">
<div class="modal-content">
<h2 id="game-over-title"></h2>
<p id="game-over-winner"></p>
<div class="modal-buttons">
<button id="play-again-btn" class="game-btn"></button>
</div>
</div>
</div>
<div id="rules-modal" class="modal-overlay">
<div class="modal-content rules-content">
<h2 id="rules-how-to-title"></h2>
<p id="rules-goal-text"></p>
<h2 id="rules-gameplay-title"></h2>
<ul id="rules-gameplay-list"></ul>
<h2 id="rules-scoring-upper-title"></h2>
<ul id="rules-scoring-upper-list"></ul>
<h2 id="rules-scoring-lower-title"></h2>
<ul id="rules-scoring-lower-list"></ul>
<div class="modal-buttons">
<button id="close-rules-btn" class="game-btn"></button>
</div>
</div>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
const lang = {
title: "Yatzy",
rules: "Regler",
mode: "Modus",
freeChoice: "Fritt valg",
forcedOrder: "Tvungen rekkef√∏lge",
rollsLeft: "Kast igjen",
rollDice: "Kast terningene",
confirmDice: "Fullf√∏r kast",
chooseOnBoard: "Velg p√• poengbrettet!",
category: "Kategori",
ones: "Enere",
twos: "Toere",
threes: "Treere",
fours: "Firere",
fives: "Femmere",
sixes: "Seksere",
bonus: "Bonus",
upperTotal: "Sum √∏vre",
threeOfAKind: "3 like",
fourOfAKind: "4 like",
fullHouse: "Hus",
smallStraight: "Liten straight",
largeStraight: "Stor straight",
yatzy: "Yatzy",
chance: "Sjanse",
lowerTotal: "Sum nedre",
grandTotal: "TOTALSUM",
welcomeTitle: "Velkommen til Yatzy!",
modeSelectText: "Velg spillmodus:",
gameOverTitle: "Spillet er over!",
playAgain: "Spill igjen",
rulesHowToTitle: "Slik spiller du Yatzy",
rulesGoalText: "M√•let er √• f√• flest poeng ved √• kaste fem terninger for √• lage bestemte kombinasjoner.",
rulesGameplayTitle: "Spillforl√∏p",
rulesGameplay1: "P√• din tur kan du kaste terningene opptil <strong>3 ganger</strong>.",
rulesGameplay2: "Etter f√∏rste og andre kast kan du klikke p√• terninger for √• 'holde' dem. Terninger du holder p√•, blir ikke kastet p√• nytt.",
rulesGameplay3: "Etter kastene dine m√• du velge en ledig kategori p√• poengbrettet for √• plassere poengsummen din.",
rulesScoringUpperTitle: "Poeng: √òvre del",
rulesScoringUpper1: "<strong>Enere til Seksere:</strong> F√• summen av terningene som viser det tallet. For eksempel gir tre 4-ere i 'Firere'-kategorien 12 poeng.",
rulesScoringUpper2: "<strong>Bonus:</strong> Hvis totalsummen av √∏vre del er <strong>63 eller mer</strong>, f√•r du en <strong>bonus p√• 50 poeng</strong>.",
rulesScoringLowerTitle: "Poeng: Nedre del",
rulesScoringLower1: "<strong>3 & 4 like:</strong> Minst 3 eller 4 terninger med samme verdi. Gir summen av alle 5 terningene i poeng.",
rulesScoringLower2: "<strong>Hus:</strong> Tre like og et par (f.eks. 4, 4, 4, 2, 2). Gir <strong>25 poeng</strong>.",
rulesScoringLower3: "<strong>Liten straight:</strong> Fire terninger i rekkef√∏lge (f.eks. 1-2-3-4). Gir <strong>30 poeng</strong>.",
rulesScoringLower4: "<strong>Stor straight:</strong> Fem terninger i rekkef√∏lge (f.eks. 1-2-3-4-5). Gir <strong>40 poeng</strong>.",
rulesScoringLower5: "<strong>Yatzy:</strong> Alle fem terningene er like. Gir <strong>50 poeng</strong>.",
rulesScoringLower6: "<strong>Sjanse:</strong> Hvilken som helst kombinasjon. Gir summen av alle 5 terningene i poeng.",
rulesGotIt: "Skj√∏nner!",
playerYou: "Du",
playerRobby: "Robby",
playerProfessor: "Professoren",
playerThinker: "Tenkeren"
};
const ROLLS_PER_TURN = 3;
const UPPER_SECTION_BONUS_THRESHOLD = 63;
const UPPER_SECTION_BONUS_POINTS = 50;
const SCORE_FOR_FULL_HOUSE = 25;
const SCORE_FOR_SMALL_STRAIGHT = 30;
const SCORE_FOR_LARGE_STRAIGHT = 40;
const SCORE_FOR_YATZY = 50;
const AI_THINKING_TIME = 1000;
const PLAYERS_CONFIG = [
{ name: lang.playerYou, emoji: 'üßë‚Äçüíª', isAI: false },
{ name: lang.playerRobby, emoji: 'ü§ñ', isAI: true },
{ name: lang.playerProfessor, emoji: 'üßê', isAI: true },
{ name: lang.playerThinker, emoji: 'ü§î', isAI: true }
];
const scoreboardEl = document.getElementById('scoreboard');
const diceContainerEl = document.getElementById('dice-container');
const rollBtn = document.getElementById('roll-btn');
const confirmBtn = document.getElementById('confirm-btn');
const rollsLeftEl = document.getElementById('rolls-left');
const currentPlayerNameEl = document.getElementById('current-player-name');
const gameModeDisplayEl = document.getElementById('game-mode-display');
const rulesBtn = document.getElementById('rules-btn');
const closeRulesBtn = document.getElementById('close-rules-btn');
const startModal = document.getElementById('start-modal');
const gameOverModal = document.getElementById('game-over-modal');
const rulesModal = document.getElementById('rules-modal');
const freeModeBtn = document.getElementById('free-mode-btn');
const forcedModeBtn = document.getElementById('forced-mode-btn');
const playAgainBtn = document.getElementById('play-again-btn');
let state = {};
const SCORE_CATEGORIES = [
{ id: 'ones', name: lang.ones, value: 1, section: 'upper' }, { id: 'twos', name: lang.twos, value: 2, section: 'upper' }, { id: 'threes', name: lang.threes, value: 3, section: 'upper' },
{ id: 'fours', name: lang.fours, value: 4, section: 'upper' }, { id: 'fives', name: lang.fives, value: 5, section: 'upper' }, { id: 'sixes', name: lang.sixes, value: 6, section: 'upper' },
{ id: 'upperBonus', name: lang.bonus, isBonus: true }, { id: 'upperTotal', name: lang.upperTotal, isTotal: true },
{ id: 'threeOfAKind', name: lang.threeOfAKind, section: 'lower' }, { id: 'fourOfAKind', name: lang.fourOfAKind, section: 'lower' },
{ id: 'fullHouse', name: lang.fullHouse, section: 'lower' }, { id: 'smallStraight', name: lang.smallStraight, section: 'lower' },
{ id: 'largeStraight', name: lang.largeStraight, section: 'lower' }, { id: 'yatzy', name: lang.yatzy, section: 'lower' },
{ id: 'chance', name: lang.chance, section: 'lower' }, { id: 'lowerTotal', name: lang.lowerTotal, isTotal: true },
{ id: 'grandTotal', name: lang.grandTotal, isTotal: true }
];
function updateStaticUIText() {
document.title = lang.title;
gameModeDisplayEl.textContent = `${lang.mode}:`;
rulesBtn.textContent = lang.rules;
rollBtn.textContent = lang.rollDice;
document.getElementById('welcome-title').textContent = lang.welcomeTitle;
document.getElementById('mode-select-text').textContent = lang.modeSelectText;
freeModeBtn.textContent = lang.freeChoice;
forcedModeBtn.textContent = lang.forcedOrder;
document.getElementById('game-over-title').textContent = lang.gameOverTitle;
playAgainBtn.textContent = lang.playAgain;
document.getElementById('rules-how-to-title').textContent = lang.rulesHowToTitle;
document.getElementById('rules-goal-text').textContent = lang.rulesGoalText;
document.getElementById('rules-gameplay-title').textContent = lang.rulesGameplayTitle;
document.getElementById('rules-gameplay-list').innerHTML = `
<li>${lang.rulesGameplay1}</li>
<li>${lang.rulesGameplay2}</li>
<li>${lang.rulesGameplay3}</li>`;
document.getElementById('rules-scoring-upper-title').textContent = lang.rulesScoringUpperTitle;
document.getElementById('rules-scoring-upper-list').innerHTML = `
<li>${lang.rulesScoringUpper1}</li>
<li>${lang.rulesScoringUpper2}</li>`;
document.getElementById('rules-scoring-lower-title').textContent = lang.rulesScoringLowerTitle;
document.getElementById('rules-scoring-lower-list').innerHTML = `
<li>${lang.rulesScoringLower1}</li>
<li>${lang.rulesScoringLower2}</li>
<li>${lang.rulesScoringLower3}</li>
<li>${lang.rulesScoringLower4}</li>
<li>${lang.rulesScoringLower5}</li>
<li>${lang.rulesScoringLower6}</li>`;
closeRulesBtn.textContent = lang.rulesGotIt;
}
function init() {
state = {
players: PLAYERS_CONFIG.map(p => ({ ...p, scores: {} })),
currentPlayerIndex: 0,
rollsLeft: ROLLS_PER_TURN,
dice: [1, 2, 3, 4, 5],
heldDice: [false, false, false, false, false],
gameMode: 'free',
phase: 'new',
gameOver: false,
turnCount: 0
};
SCORE_CATEGORIES.forEach(cat => {
if (!cat.isBonus && !cat.isTotal) {
state.players.forEach(p => { p.scores[cat.id] = null; });
}
});
setupBoard();
updateUI();
startModal.classList.add('visible');
gameOverModal.classList.remove('visible');
}
function startGame(mode) {
state.gameMode = mode;
gameModeDisplayEl.textContent = `${lang.mode}: ${mode === 'free' ? lang.freeChoice : lang.forcedOrder}`;
startModal.classList.remove('visible');
newTurn();
}
function setupBoard() {
let headerHTML = '<thead><tr>';
headerHTML += `<th>${lang.category}</th>`;
state.players.forEach(p => headerHTML += `<th class="player-header">${p.emoji}</th>`);
headerHTML += '</tr></thead>';
let bodyHTML = '<tbody>';
SCORE_CATEGORIES.forEach(cat => {
bodyHTML += `<tr class="${cat.isTotal ? 'total-score-row' : ''}" id="row-${cat.id}">`;
bodyHTML += `<td>${cat.name}</td>`;
state.players.forEach((p, pIndex) => {
if (cat.isBonus || cat.isTotal) {
bodyHTML += `<td id="${cat.id}-${pIndex}">0</td>`;
} else {
bodyHTML += `<td class="score-cell" id="${cat.id}-${pIndex}" data-cat="${cat.id}" data-player="${pIndex}">-</td>`;
}
});
bodyHTML += '</tr>';
});
bodyHTML += '</tbody>';
scoreboardEl.innerHTML = headerHTML + bodyHTML;
addScoreCellListeners();
}
function renderDice() {
const player = state.players[state.currentPlayerIndex];
diceContainerEl.innerHTML = '';
state.dice.forEach((value, i) => {
const die = document.createElement('div');
die.className = 'dice';
die.dataset.value = value;
if (state.heldDice[i]) die.classList.add('held');
if (player.isAI || state.phase !== 'rolling' || state.rollsLeft === ROLLS_PER_TURN) {
die.classList.add('no-click');
}
for (let j = 0; j < value; j++) {
die.innerHTML += '<span class="dot"></span>';
}
die.addEventListener('click', () => toggleHold(i));
diceContainerEl.appendChild(die);
});
}
function updateUI() {
const player = state.players[state.currentPlayerIndex];
const isHuman = !player.isAI;
currentPlayerNameEl.textContent = (player.name === lang.playerYou) ? 'Din tur' : `${player.name} sin tur`;
rollsLeftEl.textContent = `${lang.rollsLeft}: ${state.rollsLeft}`;
if (isHuman) {
if (state.phase === 'rolling') {
rollBtn.style.display = 'block';
rollBtn.disabled = (state.rollsLeft === 0);
confirmBtn.style.display = (state.rollsLeft < ROLLS_PER_TURN) ? 'block' : 'none';
confirmBtn.disabled = false;
confirmBtn.textContent = lang.confirmDice;
} else if (state.phase === 'scoring') {
rollBtn.style.display = 'none';
confirmBtn.style.display = 'block';
confirmBtn.disabled = true;
confirmBtn.textContent = lang.chooseOnBoard;
} else {
rollBtn.style.display = 'block';
rollBtn.disabled = true;
confirmBtn.style.display = 'none';
}
} else {
rollBtn.style.display = 'block';
rollBtn.disabled = true;
confirmBtn.style.display = 'none';
}
document.querySelectorAll('.score-cell').forEach(cell => {
const pIndex = parseInt(cell.dataset.player);
const catId = cell.dataset.cat;
// Nullstill klasser for forslag og tilgjengelighet
cell.classList.remove('available', 'suggestion');
if (pIndex === state.currentPlayerIndex && isHuman && state.phase === 'scoring' && state.players[pIndex].scores[catId] === null) {
    if (state.gameMode === 'forced') {
        if (getNextForcedCategory(pIndex) && getNextForcedCategory(pIndex).id === catId) {
            cell.classList.add('available');
            if (calculateScore(catId, state.dice) > 0) {
                cell.classList.add('suggestion');
            }
        }
    } else { // 'free' mode
        // Alle tomme ruter er klikkbare (available) for strategisk plassering av null poeng
        cell.classList.add('available');
        // Men kun ruter som gir poeng f√•r den pulserende 'suggestion'-effekten
        if (calculateScore(catId, state.dice) > 0) {
            cell.classList.add('suggestion');
        }
    }
}
if (state.players[pIndex].scores[catId] !== null) {
cell.classList.add('filled');
cell.textContent = state.players[pIndex].scores[catId];
} else {
cell.classList.remove('filled');
cell.textContent = '-';
}
});
scoreboardEl.querySelectorAll('th, td').forEach(el => el.style.backgroundColor = '');
const header = scoreboardEl.querySelector(`th:nth-child(${state.currentPlayerIndex + 2})`);
if (header) {
header.style.backgroundColor = 'var(--secondary-color)';
}
renderDice();
}
function addScoreCellListeners() {
document.querySelectorAll('.score-cell').forEach(cell => {
cell.addEventListener('click', () => {
if (cell.classList.contains('available')) {
selectScore(cell.dataset.cat, parseInt(cell.dataset.player));
}
});
});
}
function updateTotals(playerIndex) {
const p = state.players[playerIndex];
let upperScore = 0;
let lowerScore = 0;
for (let i = 0; i < 6; i++) {
const catId = SCORE_CATEGORIES[i].id;
if (p.scores[catId] !== null) upperScore += p.scores[catId];
}
let bonus = (upperScore >= UPPER_SECTION_BONUS_THRESHOLD) ? UPPER_SECTION_BONUS_POINTS : 0;
document.getElementById(`upperBonus-${playerIndex}`).textContent = bonus;
document.getElementById(`upperTotal-${playerIndex}`).textContent = upperScore + bonus;
for (let i = 8; i < 15; i++) {
const catId = SCORE_CATEGORIES[i].id;
if (p.scores[catId] !== null) lowerScore += p.scores[catId];
}
document.getElementById(`lowerTotal-${playerIndex}`).textContent = lowerScore;
document.getElementById(`grandTotal-${playerIndex}`).textContent = upperScore + bonus + lowerScore;
}
function rollDice() {
if (state.rollsLeft <= 0 || state.phase !== 'rolling') {
return;
}
state.rollsLeft--;
state.dice = state.dice.map((d, i) =>
state.heldDice[i] ? d : Math.floor(Math.random() * 6) + 1
);
updateUI();
}
function toggleHold(index) {
const player = state.players[state.currentPlayerIndex];
if (!player.isAI && state.phase === 'rolling' && state.rollsLeft < ROLLS_PER_TURN) {
state.heldDice[index] = !state.heldDice[index];
renderDice();
}
}
function selectScore(categoryId, playerIndex) {
if (playerIndex !== state.currentPlayerIndex || state.gameOver) return;
const player = state.players[playerIndex];
if (player.scores[categoryId] !== null) return;
player.scores[categoryId] = calculateScore(categoryId, state.dice);
updateTotals(playerIndex);
state.turnCount++;
if (state.turnCount >= SCORE_CATEGORIES.filter(c => c.section).length * state.players.length) {
endGame();
} else {
nextPlayer();
}
}
function newTurn() {
state.rollsLeft = ROLLS_PER_TURN;
state.heldDice = [false, false, false, false, false];
state.phase = 'rolling';
const player = state.players[state.currentPlayerIndex];
if (player.isAI) {
updateUI();
setTimeout(runAITurn, AI_THINKING_TIME);
} else {
updateUI();
}
}
function nextPlayer() {
state.currentPlayerIndex = (state.currentPlayerIndex + 1) % state.players.length;
newTurn();
}
function getPlayerTotal(playerIndex) {
const p = state.players[playerIndex];
let upperScore = 0;
let lowerScore = 0;
SCORE_CATEGORIES.forEach(cat => {
if (p.scores[cat.id] !== null) {
if (cat.section === 'upper') {
upperScore += p.scores[cat.id];
} else if (cat.section === 'lower') {
lowerScore += p.scores[cat.id];
}
}
});
const bonus = (upperScore >= UPPER_SECTION_BONUS_THRESHOLD) ? UPPER_SECTION_BONUS_POINTS : 0;
return upperScore + bonus + lowerScore;
}
function endGame() {
state.gameOver = true;
state.phase = 'over';
updateUI();
let winner = state.players[0];
let maxScore = -1;
state.players.forEach((p, index) => {
const totalScore = getPlayerTotal(index);
if (totalScore > maxScore) {
maxScore = totalScore;
winner = p;
}
});
gameOverModal.classList.add('visible');
document.getElementById('game-over-title').textContent = lang.gameOverTitle;
document.getElementById('game-over-winner').textContent = `Vinneren er ${winner.name} med ${maxScore} poeng!`;
}
function getNextForcedCategory(playerIndex) {
const p = state.players[playerIndex];
return SCORE_CATEGORIES.find(cat => cat.section && p.scores[cat.id] === null);
}
function calculateScore(category, dice) {
const counts = dice.reduce((acc, d) => { acc[d] = (acc[d] || 0) + 1; return acc; }, {});
const sum = dice.reduce((a, b) => a + b, 0);
const sortedUnique = [...new Set(dice)].sort((a, b) => a - b);
switch (category) {
case 'ones': return (counts[1] || 0) * 1;
case 'twos': return (counts[2] || 0) * 2;
case 'threes': return (counts[3] || 0) * 3;
case 'fours': return (counts[4] || 0) * 4;
case 'fives': return (counts[5] || 0) * 5;
case 'sixes': return (counts[6] || 0) * 6;
case 'threeOfAKind':
return Object.values(counts).some(c => c >= 3) ? sum : 0;
case 'fourOfAKind':
return Object.values(counts).some(c => c >= 4) ? sum : 0;
case 'fullHouse':
const vals = Object.values(counts);
return vals.includes(3) && vals.includes(2) ? SCORE_FOR_FULL_HOUSE : 0;
case 'smallStraight':
const straights = ["1234", "2345", "3456"];
const diceStr = sortedUnique.join('');
for (const s of straights) {
if (diceStr.includes(s)) return SCORE_FOR_SMALL_STRAIGHT;
}
return 0;
case 'largeStraight':
return sortedUnique.length === 5 && (sortedUnique[4] - sortedUnique[0] === 4) ? SCORE_FOR_LARGE_STRAIGHT : 0;
case 'yatzy':
return Object.values(counts).some(c => c >= 5) ? SCORE_FOR_YATZY : 0;
case 'chance':
return sum;
default: return 0;
}
}
const getHoldArray = (dice, valuesToKeep) => {
const tempDice = [...dice];
const hold = Array(5).fill(false);
valuesToKeep.forEach(val => {
const index = tempDice.indexOf(val);
if (index > -1) {
hold[index] = true;
tempDice[index] = -1;
}
});
return hold;
};
function runAITurn() {
if (state.gameOver) return;
const aiRoll = () => {
if (state.rollsLeft > 0 && !state.gameOver) {
rollDice();
setTimeout(() => {
const decision = aiDecideHold(state.dice, state.players[state.currentPlayerIndex]);
state.heldDice = decision.hold;
if (decision.shouldScoreNow || state.rollsLeft === 0) {
state.phase = 'scoring';
setTimeout(aiSelectScore, AI_THINKING_TIME);
} else {
setTimeout(aiRoll, AI_THINKING_TIME);
}
}, AI_THINKING_TIME);
} else if (!state.gameOver) {
state.phase = 'scoring';
setTimeout(aiSelectScore, AI_THINKING_TIME);
}
};
aiRoll();
}
function aiDecideHold(dice, player) {
if (state.gameMode === 'forced') {
const targetCategory = getNextForcedCategory(state.currentPlayerIndex);
if (!targetCategory) return { hold: [true, true, true, true, true], shouldScoreNow: true };
return decideHoldForcedMode(dice, targetCategory.id);
} else {
return decideHoldFreeMode(dice, player);
}
}
function decideHoldForcedMode(dice, targetCategoryId) {
const counts = dice.reduce((acc, d) => { acc[d] = (acc[d] || 0) + 1; return acc; }, {});
let keepers = [];
switch (targetCategoryId) {
case 'ones': case 'twos': case 'threes': case 'fours': case 'fives': case 'sixes':
const targetNum = SCORE_CATEGORIES.find(c => c.id === targetCategoryId).value;
keepers = dice.filter(d => d === targetNum);
break;
case 'threeOfAKind': case 'fourOfAKind': case 'yatzy':
const mostFrequent = Object.entries(counts).sort((a, b) => b[1] - a[1])[0];
if (mostFrequent) {
keepers = dice.filter(d => d === Number(mostFrequent[0]));
}
break;
case 'fullHouse':
const three = Object.entries(counts).find(([val, count]) => count === 3);
const pair = Object.entries(counts).find(([val, count]) => count === 2);
if (three) {
keepers.push(...dice.filter(d => d === Number(three[0])));
}
if (pair) {
keepers.push(...dice.filter(d => d === Number(pair[0])));
}
if (keepers.length === 0 && pair) {
keepers.push(...dice.filter(d => d === Number(pair[0])));
}
break;
case 'smallStraight': case 'largeStraight':
let bestStraight = [];
let uniqueDice = [...new Set(dice)].sort((a, b) => a - b);
for (let i = 0; i < (1 << uniqueDice.length); i++) {
let subset = [];
for (let j = 0; j < uniqueDice.length; j++) {
if ((i >> j) & 1) {
subset.push(uniqueDice[j]);
}
}
if (subset.length > 1 && (subset[subset.length - 1] - subset[0] === subset.length - 1)) {
if (subset.length > bestStraight.length) {
bestStraight = subset;
}
}
}
keepers = bestStraight;
break;
case 'chance':
keepers = dice.filter(d => d >= 4);
if (keepers.length === 0) {
keepers = [Math.max(...dice)];
}
break;
}
return {
hold: getHoldArray(dice, keepers),
shouldScoreNow: keepers.length === 5 && calculateScore(targetCategoryId, dice) > 0,
};
}
function decideHoldFreeMode(dice, player) {
const availableCats = SCORE_CATEGORIES.filter(c => c.section && player.scores[c.id] === null);
const counts = dice.reduce((acc, d) => { acc[d] = (acc[d] || 0) + 1; return acc; }, {});
const sortedUnique = [...new Set(dice)].sort((a, b) => a - b);
const options = [];
let upperSectionScore = 0;
for (let i = 0; i < 6; i++) {
const catId = SCORE_CATEGORIES[i].id;
if (player.scores[catId] !== null) {
upperSectionScore += player.scores[catId];
}
}
if (upperSectionScore < UPPER_SECTION_BONUS_THRESHOLD) {
for (let i = 1; i <= 6; i++) {
const catId = SCORE_CATEGORIES.find(c => c.value === i).id;
if (player.scores[catId] === null && counts[i] > 1) {
options.push({
priority: 60 + i,
keepers: dice.filter(d => d === i),
shouldScoreNow: false
});
}
}
}
if (availableCats.some(c => c.id === 'yatzy') && calculateScore('yatzy', dice) > 0) {
options.push({ priority: 100, keepers: dice, shouldScoreNow: true });
}
if (availableCats.some(c => c.id === 'largeStraight') && calculateScore('largeStraight', dice) > 0) {
options.push({ priority: 95, keepers: dice, shouldScoreNow: true });
}
if (availableCats.some(c => c.id === 'smallStraight') && calculateScore('smallStraight', dice) > 0) {
options.push({ priority: 90, keepers: dice, shouldScoreNow: true });
}
if (availableCats.some(c => c.id === 'fullHouse') && calculateScore('fullHouse', dice) > 0) {
options.push({ priority: 80, keepers: dice, shouldScoreNow: true });
}
const [fourVal, fourCount] = Object.entries(counts).find(([v, c]) => c >= 4) || [];
if (fourCount >= 4) {
options.push({ priority: 85, keepers: dice.filter(d => d === Number(fourVal)), shouldScoreNow: false });
}
const threeVal = Object.entries(counts).find(([v, c]) => c === 3);
if (threeVal) {
options.push({ priority: 75, keepers: dice.filter(d => d === Number(threeVal[0])), shouldScoreNow: false });
}
let bestStraight = [];
for (let i = 0; i < (1 << sortedUnique.length); i++) {
let subset = [];
for (let j = 0; j < sortedUnique.length; j++) {
if ((i >> j) & 1) subset.push(sortedUnique[j]);
}
let isContiguous = subset.every((val, k, arr) => k === 0 || val === arr[k - 1] + 1);
if (isContiguous && subset.length > bestStraight.length) {
bestStraight = subset;
}
}
if (bestStraight.length >= 3) {
options.push({ priority: 70, keepers: bestStraight, shouldScoreNow: false });
}
const pairs = Object.entries(counts).filter(([v, c]) => c === 2);
if (pairs.length === 2) {
const keepers = dice.filter(d => d === Number(pairs[0][0]) || d === Number(pairs[1][0]));
options.push({ priority: 65, keepers: keepers, shouldScoreNow: false });
}
const highPairVal = Object.entries(counts).filter(([v, c]) => c === 2).map(([v, c]) => Number(v)).sort((a, b) => b - a)[0];
if (highPairVal) {
options.push({ priority: 50, keepers: dice.filter(d => d === highPairVal), shouldScoreNow: false });
}
if (options.length === 0) {
options.push({ priority: 1, keepers: [Math.max(...dice)] });
}
const bestOption = options.sort((a, b) => b.priority - a.priority)[0];
return {
hold: getHoldArray(dice, bestOption.keepers || []),
shouldScoreNow: bestOption.shouldScoreNow || false,
};
}
function aiSelectScore() {
if (state.gameOver) return;
const player = state.players[state.currentPlayerIndex];
if (state.gameMode === 'forced') {
const cat = getNextForcedCategory(state.currentPlayerIndex);
if (cat) {
selectScore(cat.id, state.currentPlayerIndex);
}
return;
}
let bestChoice = { categoryId: null, score: -1, desirability: -1 };
const categoryDesirability = {
yatzy: 10, fullHouse: 9, largeStraight: 9, fourOfAKind: 8, smallStraight: 8,
sixes: 6, fives: 5, threeOfAKind: 4, fours: 4, chance: 3, threes: 3, twos: 2, ones: 1
};
const availableCats = SCORE_CATEGORIES.filter(c => c.section && player.scores[c.id] === null);
let currentUpperScore = 0;
const upperSectionCats = SCORE_CATEGORIES.filter(c => c.section === 'upper');
upperSectionCats.forEach(cat => {
if (player.scores[cat.id] !== null) {
currentUpperScore += player.scores[cat.id];
}
});
let bestUpperScore = -1;
let bestUpperCat = null;
upperSectionCats.filter(c => player.scores[c.id] === null).forEach(cat => {
const score = calculateScore(cat.id, state.dice);
if (score > bestUpperScore) {
bestUpperScore = score;
bestUpperCat = cat.id;
}
});
if (currentUpperScore + bestUpperScore >= UPPER_SECTION_BONUS_THRESHOLD && bestUpperScore > 0) {
selectScore(bestUpperCat, state.currentPlayerIndex);
return;
}
availableCats.forEach(cat => {
const score = calculateScore(cat.id, state.dice);
const desirability = categoryDesirability[cat.id] || 0;
let effectiveScore = score;
if (score > 0) {
if (cat.id === 'yatzy') effectiveScore += 50;
if (cat.id === 'largeStraight') effectiveScore += 40;
}
if (effectiveScore > bestChoice.score) {
bestChoice = { categoryId: cat.id, score: effectiveScore, desirability: desirability };
} else if (effectiveScore === bestChoice.score && desirability > bestChoice.desirability) {
bestChoice = { categoryId: cat.id, score: effectiveScore, desirability: desirability };
}
});
if (bestChoice.score <= 0) {
const sortedByDesirability = availableCats.sort((a, b) => (categoryDesirability[a.id] || 0) - (categoryDesirability[b.id] || 0));
bestChoice.categoryId = sortedByDesirability[0]?.id;
}
if (bestChoice.categoryId) {
selectScore(bestChoice.categoryId, state.currentPlayerIndex);
} else if (!state.gameOver) {
const fallbackCat = availableCats[0];
if (fallbackCat) {
selectScore(fallbackCat.id, state.currentPlayerIndex);
} else {
endGame();
}
}
}
rollBtn.addEventListener('click', rollDice);
confirmBtn.addEventListener('click', () => {
if (state.phase === 'rolling') {
state.phase = 'scoring';
updateUI();
}
});
freeModeBtn.addEventListener('click', () => startGame('free'));
forcedModeBtn.addEventListener('click', () => startGame('forced'));
playAgainBtn.addEventListener('click', init);
rulesBtn.addEventListener('click', () => rulesModal.classList.add('visible'));
closeRulesBtn.addEventListener('click', () => rulesModal.classList.remove('visible'));
rulesModal.addEventListener('click', (e) => {
if (e.target === rulesModal) {
rulesModal.classList.remove('visible');
}
});
updateStaticUIText();
init();
});
</script>
</body>
</html>
